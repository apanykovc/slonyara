# Архитектура бота напоминаний

Документ описывает целевую архитектуру приложения и обязанности каждого
уровня. Структура выстроена слоями, где каждый следующий слой может
зависеть только от нижележащих.

## Слои приложения

1. **`config`** – загрузка конфигурации и описания окружения. Слой
   отвечает за чтение `.env`, файлы конфигурации и валидацию значений.
2. **`data`** – работа с хранилищем. Репозитории предоставляют
   высокоуровневые методы доступа к данным (чаты, встречи, пользователи),
   не раскрывая деталей хранения (SQLite/файлы/память).
3. **`services`** – бизнес-логика. Инкапсулирует сценарии работы бота:
   управление встречами, вычисление напоминаний, проверка прав и т. д.
4. **`routers`** – маршрутизация команд и колбэков. Здесь описываются
   хендлеры для приватных сообщений и групповых чатов, которые вызывают
   сервисы и подготавливают контекст для UI.
5. **`ui`** – формирование интерфейса Telegram: генерация клавиатур,
   форматирование сообщений, шаблоны текстов.
6. **`scheduler`** – планировщик периодических задач: рассылка
   напоминаний, очистка устаревших данных, технические задачи.
7. **`infra`** – вспомогательная инфраструктура: интеграция с Telegram,
   ретраи, блокировки, очереди, кэш и т. п.

## TelegramSender и безопасные вызовы Telegram API

Инфраструктурный слой предоставляет компонент `TelegramSender` с методом
`safe_tg_call`. Он отвечает за отправку запросов в Telegram API через
централизованную очередь.

Особенности реализации:

- **Очередь**. Все вызовы Telegram проходят через общую асинхронную
  очередь, что позволяет дозировать нагрузку и уважать ограничения API.
- **Ретраи**. Для временных ошибок применяется экспоненциальный бэкофф с
  джиттером. Количество попыток и базовые интервалы задаются в
  конфигурации. Каждая попытка логируется с указанием номера повтора.
- **Дедупликация**. Повторяющиеся вызовы с одинаковым ключом
  (например, `chat_id` + тело сообщения) объединяются, чтобы не
  отправлять дубликаты при повторной обработке апдейта.

## Клик-гвард

Для предотвращения повторной обработки кнопок используется механизм
«клик-гварда»:

1. Перед выполнением действия создаётся TTL-замок на комбинацию
   `callback_id` и/или `user_action`.
2. Пока замок активен, клавиатура помечается как «замороженная»: кнопки
   становятся неактивными или возвращают сообщение о повторной попытке.
3. После успешного выполнения операции замок удаляется, а клавиатура
   размораживается (отправляется обновлённый markup или снимается
   ограничение).

Это защищает от случайных дублей и повторных кликов при длительных
операциях.

## Логирование и метрики

Логи ведутся в структурированном формате (например, JSON) и поддерживают
следующие практики:

- **Уровни**: INFO — успешные операции и основные этапы; WARN —
  повторные попытки, временные ошибки; ERROR — необработанные
  исключения.
- **Корреляция**: каждый апдейт получает `request_id`, который
  прокидывается через все слои для связывания записей в логе.
- **Метрики**: счётчики количества успешных операций, ретраев и
  таймаутов. Их можно экспортировать в Prometheus/StatsD или журналировать
  в отдельную коллекцию для последующего анализа.

Такая архитектура облегчает сопровождение, позволяет расширять
функциональность без плотной связанности модулей и повышает
наблюдаемость работы бота.
